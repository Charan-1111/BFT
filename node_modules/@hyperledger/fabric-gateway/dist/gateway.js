"use strict";
/*
 * Copyright 2020 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GatewayImpl_client, _GatewayImpl_signingIdentity;
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertDefined = exports.internalConnect = exports.connect = void 0;
const chaincodeeventsrequest_1 = require("./chaincodeeventsrequest");
const client_1 = require("./client");
const commit_1 = require("./commit");
const network_1 = require("./network");
const proposal_1 = require("./proposal");
const common_pb_1 = require("./protos/common/common_pb");
const gateway_pb_1 = require("./protos/gateway/gateway_pb");
const proposal_pb_1 = require("./protos/peer/proposal_pb");
const signingidentity_1 = require("./signingidentity");
const transaction_1 = require("./transaction");
/**
 * Connect to a Fabric Gateway using a client identity, gRPC connection and signing implementation.
 * @param options - Connection options.
 * @returns A connected gateway.
 */
function connect(options) {
    return internalConnect(options);
}
exports.connect = connect;
function internalConnect(options) {
    if (!options.client) {
        throw new Error('No client connection supplied');
    }
    if (!options.identity) {
        throw new Error('No identity supplied');
    }
    const signingIdentity = new signingidentity_1.SigningIdentity(options);
    const gatewayClient = (0, client_1.newGatewayClient)(options.client, options);
    return new GatewayImpl(gatewayClient, signingIdentity);
}
exports.internalConnect = internalConnect;
class GatewayImpl {
    constructor(client, signingIdentity) {
        _GatewayImpl_client.set(this, void 0);
        _GatewayImpl_signingIdentity.set(this, void 0);
        __classPrivateFieldSet(this, _GatewayImpl_client, client, "f");
        __classPrivateFieldSet(this, _GatewayImpl_signingIdentity, signingIdentity, "f");
    }
    getIdentity() {
        return __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f").getIdentity();
    }
    getNetwork(channelName) {
        return new network_1.NetworkImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            channelName
        });
    }
    newSignedProposal(bytes, signature) {
        const proposedTransaction = gateway_pb_1.ProposedTransaction.deserializeBinary(bytes);
        const signedProposal = assertDefined(proposedTransaction.getProposal(), 'Missing signed proposal');
        const proposal = proposal_pb_1.Proposal.deserializeBinary(signedProposal.getProposalBytes_asU8());
        const header = common_pb_1.Header.deserializeBinary(proposal.getHeader_asU8());
        const channelHeader = common_pb_1.ChannelHeader.deserializeBinary(header.getChannelHeader_asU8());
        const result = new proposal_1.ProposalImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            channelName: channelHeader.getChannelId(),
            proposedTransaction,
        });
        result.setSignature(signature);
        return result;
    }
    newSignedTransaction(bytes, signature) {
        const preparedTransaction = gateway_pb_1.PreparedTransaction.deserializeBinary(bytes);
        const result = new transaction_1.TransactionImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            preparedTransaction,
        });
        result.setSignature(signature);
        return result;
    }
    newSignedCommit(bytes, signature) {
        const signedRequest = gateway_pb_1.SignedCommitStatusRequest.deserializeBinary(bytes);
        const request = gateway_pb_1.CommitStatusRequest.deserializeBinary(signedRequest.getRequest_asU8());
        const result = new commit_1.CommitImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            transactionId: request.getTransactionId(),
            signedRequest: signedRequest,
        });
        result.setSignature(signature);
        return result;
    }
    newSignedChaincodeEventsRequest(bytes, signature) {
        const request = gateway_pb_1.ChaincodeEventsRequest.deserializeBinary(bytes);
        const result = new chaincodeeventsrequest_1.ChaincodeEventsRequestImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            request,
        });
        result.setSignature(signature);
        return result;
    }
    close() {
        // Nothing for now
    }
}
_GatewayImpl_client = new WeakMap(), _GatewayImpl_signingIdentity = new WeakMap();
function assertDefined(value, message) {
    if (value == undefined) {
        throw new Error(message);
    }
    return value;
}
exports.assertDefined = assertDefined;
//# sourceMappingURL=gateway.js.map